<html>
  <head>
    <meta charset="utf-8" />
    <title>关系图示例</title>
    <style>
      .div-left {
        float: right;
      }
    </style>
    <!--  <script charset="utf-8" src="/ews/js/r2d3.min.js"></script> -->
<script src="http://d3js.org/d3.v4.min.js"></script>

    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
    <script>
      function hy() {
        circle
          .style("fill", function (node) {
            return "black";
          })
          .style("stroke", function (node) {
            return "green";
          });
        circle.style("stroke-width", 1);
        text.style("fill", "#000000");
        edges_text.style("fill", "#000000");
        path.style("stroke-width", 0.5);
        path.style("stroke", function (d) {
          return "red";
        });
      }
      function lxclick() {
        var aa = [];
        if (document.getElementById("lxa").checked) {
          aa[aa.length] = "01";
        }
        if (document.getElementById("lxb").checked) {
          aa[aa.length] = "02";
        }
        if (document.getElementById("lxc").checked) {
          aa[aa.length] = "03";
        }

        if (aa.length == 0) {
          hy();
        } else {
          edges_text.style("fill", function (line) {
            return "#ccc";
          });

          text.style("fill", function (data) {
            var color = "#BEBEBE";
            for (var i = 0; i < links.length; i++) {
              if (aa.indexOf(links[i].rela) >= 0) {
                if (
                  links[i].source.name == data.name ||
                  links[i].target.name == data.name
                ) {
                  color = "#000000";
                }
              }
            }
            return color;
          });
          circle.style("stroke", function (data) {
            return "yellow";
          });
          circle.style("fill", function (data) {
            return "orange";
          });
          circle.style("stroke-width", function (data) {
            return 3;
          });
          //处理弧线
          path.style("stroke-width", function (line) {
            return 1;
          });

          path.style("stroke", function (line) {
            return "pink";
          });
        }
      }
    </script>
  </head>
  <style>
    .link {
      fill: none;
      stroke: #666;
      stroke-width: 1.5px;
    }

    #licensing {
      fill: green;
    }

    .link.licensing {
      stroke: green;
    }

    .link.resolved {
      stroke-dasharray: 0, 2 1;
    }

    circle {
      fill: #ccc;
      stroke: #333;
      stroke-width: 1.5px;
    }

    text {
      font: 12px Microsoft YaHei;
      pointer-events: none;
      text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    }

    .linetext {
      font-size: 12px Microsoft YaHei;
    }
  </style>
  <body id="body" bgcolor="#F0Ffff">
    <script>
      var links = [
        {
          targetname: "哇哈哈",
          relaname: "1关系",
          sourcename: "洗刷刷",
          source: "bh001",
          target: "bh002",
        },
        {
          targetname: "哇哈哈",
          relaname: "2关系",
          sourcename: "洗刷刷",
          source: "bh001",
          target: "bh002",
        },
        {
          targetname: "哇哈哈",
          relaname: "3关系",
          sourcename: "洗刷刷",
          source: "bh001",
          target: "bh002",
        },
        {
          targetname: "喜洋洋",
          relaname: "2关系",
          sourcename: "美洋洋",
          source: "bh003",
          target: "bh004",
        },
        {
          targetname: "洗刷刷",
          relaname: "3关系",
          sourcename: "喜洋洋",
          source: "bh003",
          target: "bh001",
        },
        {
          targetname: "喜洋洋",
          relaname: "1关系",
          sourcename: "洗刷刷",
          source: "bh004",
          target: "bh003",
        },
      ];
      //关系分组
      var linkGroup = {};
      var tips = {};
      var shiftKey;
      //对连接线进行统计和分组，不区分连接线的方向，只要属于同两个实体，即认为是同一组
      var linkmap = {};
      for (var i = 0; i < links.length; i++) {
        var key =
          links[i].source < links[i].target
            ? links[i].source + ":" + links[i].target
            : links[i].target + ":" + links[i].source;
        if (!linkmap.hasOwnProperty(key)) {
          linkmap[key] = 0;
        }
        linkmap[key] += 1;
        if (!linkGroup.hasOwnProperty(key)) {
          linkGroup[key] = [];
        }
        linkGroup[key].push(links[i]);
      }
      //为每一条连接线分配size属性，同时对每一组连接线进行编号
      for (var i = 0; i < links.length; i++) {
        var key =
          links[i].source < links[i].target
            ? links[i].source + ":" + links[i].target
            : links[i].target + ":" + links[i].source;
        links[i].size = linkmap[key];
        //同一组的关系进行编号
        var group = linkGroup[key];
        var keyPair = key.split(":");
        var type = "noself"; //标示该组关系是指向两个不同实体还是同一个实体
        if (keyPair[0] == keyPair[1]) {
          type = "self";
        }
        //给节点分配编号
        setLinkNumber(group, type);
      }

      //定义参数
      var nodes = {};
      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        link.selected = false;
        link.previouslySelected = false;
        link.source =
          nodes[link.source] ||
          (nodes[link.source] = {
            name: link.source,
            names: link.sourcename,
          });
        link.target =
          nodes[link.target] ||
          (nodes[link.target] = {
            name: link.target,
            names: link.targetname,
          });
      }

      //可以定义展示大小
      var width = 1000,
        height = 540;
      var force = d3.layout
        .force() //layout将json格式转化为力学图可用的格式
        .nodes(d3.values(nodes)) //设定节点数组
        .links(links) //设定连线数组
        .size([width, height]) //作用域的大小
        .linkDistance(250) //连接线长度
        .charge(-1100) //顶点的电荷数。该参数决定是排斥还是吸引，数值越小越互相排斥
        .on("tick", tick) //指时间间隔，隔一段时间刷新一次画面
        .start(); //开始转换
      var svg = d3
        .select("body")
        .attr("tabindex", 1)
        .on("keydown.brush", keydowned)
        .on("keyup.brush", keyupped)
        .each(function () {
          this.focus();
        })
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      var brush = svg.append("g").attr("class", "brush");
      brush.call(
        d3
          .brush()
          .extent([
            [0, 0],
            [width, height],
          ])
          .on("start", brushstarted)
          .on("brush", brushed)
          .on("end", brushended)
      );
      //箭头
      var marker = svg
        .append("marker")
        .attr("id", function (d) {
          return d;
        })
        .attr("id", "resolved")
        .attr("markerUnits", "strokeWidth") //设置为strokeWidth箭头会随着线的粗细发生变化
        .attr("markerUnits", "userSpaceOnUse")
        .attr("viewBox", "0 -5 10 10") //坐标系的区域
        .attr("refX", 32) //箭头坐标
        .attr("refY", -1)
        .attr("markerWidth", 12) //标识的大小
        .attr("markerHeight", 12)
        .attr("orient", "auto") //绘制方向，可设定为：auto（自动确认方向）和 角度值
        .attr("stroke-width", 2) //箭头宽度
        .append("path")
        .attr("d", "M0,-5L10,0L0,5") //箭头的路径
        .attr("fill", "#6c6c6c"); //箭头颜色

      // 将连接线设置为曲线
      var path = svg
        .append("g")
        .selectAll("path")
        .data(force.links())
        .enter()
        .append("path")
        .attr("class", function (d) {
          return "link " + d.type;
        })
        .attr({
          id: function (d, i) {
            return "edgepath" + i;
          },
        })
        .style("stroke", function (d) {
          //根据关联关系的不同设置线条颜色
          return "purple";
        })
        .on("mousemove", function (e) {
          setTips(e, `${e.sourcename}=>${e.targetname}`);
        })
        .on("mouseout", function (e) {
          initTips(e);
        })
        .style("stroke-width", 3) //线条粗细
        .attr("marker-end", "url(#resolved)");

      //设置直线上的字
      var edges_text = svg
        .append("g")
        .selectAll(".edgelabel")
        .data(force.links())
        .enter()
        .append("text")
        .style("pointer-events", "none")
        .attr("class", "linetext")
        .attr({
          class: "edgelabel",
          id: function (d, i) {
            return "edgepath" + i;
          },
          dx: 50,
          dy: 0,
        });
      edges_text
        .append("textPath")
        .attr("xlink:href", function (d, i) {
          return "#edgepath" + i;
        })
        .style("pointer-events", "none")
        .text(function (d) {
          return d.relaname;
        });

      //圆圈
      var circle = svg
        .append("g")
        .selectAll("circle")
        .data(force.nodes()) //表示使用force.nodes数据
        .enter()
        .append("circle")
        .style("stroke-width", function (data) {
          return 1;
        })
        .style("fill", function (node) {
          //圆圈背景色
          //根据客户不同定义圆圈颜色
          return "blue";
        })
        .style("stroke", function (node) {
          //圆圈线条的颜色
          return "orange";
        })
        .attr("r", 25) //设置圆圈半径
        .on("dblclick", function (node) {
          // alert("names:"+node.names+" , name:"+node.name);
          console.log(123);
        })

        //给圆圈添加单机事件
        .on("click", function (node) {
          //单击时圆圈上的字
          text.style("fill", function (data) {
            return "#fff";
          });
          //单击时圆圈边线宽度
          circle.style("stroke-width", function (data) {
            return 10;
          });
          //单击时圆圈背景色
          circle.style("fill", function (data) {
            var color = "#FFFAF0"; //圆圈背景色
          });
          //单击时圆圈边缘线颜色
          circle.style("stroke", function (data) {
            return "red";
          });
          //单击时让连接线加粗
          path.style("stroke-width", function (line) {
            return 5;
          });
          path.style("stroke", function (line) {
            return "red";
          });
          //单击时让连接线文字
          edges_text.style("fill", function (line) {
            return "#000000";
          });
        })
        .on("mousemove", function (e) {
          setTips(e);
        })
        .on("mouseout", function (e) {
          initTips(e);
        })
        .call(force.drag); //将当前选中的元素传到drag函数中，使顶点可以被拖动

      //圆圈的提示文字
      circle.append("svg:title").text(function (node) {
        return "双击可查看详情";
      });

      //圆圈上的字
      var text = svg
        .append("g")
        .selectAll("text")
        .data(force.nodes())
        //返回缺失元素的占位对象（placeholder），指向绑定的数据中比选定元素集多出的一部分元素。
        .enter()
        .append("text")
        .attr("dy", ".35em")
        .attr("text-anchor", "middle") //在圆圈中加上数据
        .style("fill", function (node) {
          return "#A254A2";
        })
        .attr("x", function (d) {
          // console.log(d.name+"---"+ d.name.length);
          var re_en = /[a-zA-Z]+/g;
          //如果是全英文，不换行
          if (d.names.match(re_en)) {
            d3.select(this)
              .append("tspan")
              .attr("x", 0)
              .attr("y", 2)
              .text(function () {
                return d.names;
              });
          }
          //如果小于四个字符，不换行
          else if (d.names.length <= 4) {
            d3.select(this)
              .append("tspan")
              .attr("x", 0)
              .attr("y", 2)
              .text(function () {
                return d.names;
              });
          } else {
            var top = d.names.substring(0, 4);
            var bot = d.names.substring(4, d.names.length);

            d3.select(this).text(function () {
              return "";
            });

            d3.select(this)
              .append("tspan")
              .attr("x", 0)
              .attr("y", -7)
              .text(function () {
                return top;
              });

            d3.select(this)
              .append("tspan")
              .attr("x", 0)
              .attr("y", 10)
              .text(function () {
                return bot;
              });
          }
          //直接显示文字
          /*.text(function(d) { 
        return d.name; */
        });

      //定义坐标
      function tick() {
        path.attr("d", function (d) {
          //如果连接线连接的是同一个实体，则对path属性进行调整，绘制的圆弧属于长圆弧，同时对终点坐标进行微调，避免因坐标一致导致弧无法绘制
          if (d.target == d.source) {
            dr = 30 / d.linknum;
            return (
              "M" +
              d.source.x +
              "," +
              d.source.y +
              "A" +
              dr +
              "," +
              dr +
              " 0 1,1 " +
              d.target.x +
              "," +
              (d.target.y + 1)
            );
          } else if (d.size % 2 != 0 && d.linknum == 1) {
            //如果两个节点之间的连接线数量为奇数条，则设置编号为1的连接线为直线，其他连接线会均分在两边
            return (
              "M " +
              d.source.x +
              " " +
              d.source.y +
              " L " +
              d.target.x +
              " " +
              d.target.y
            );
          }
          //根据连接线编号值来动态确定该条椭圆弧线的长半轴和短半轴，当两者一致时绘制的是圆弧
          //注意A属性后面的参数，前两个为长半轴和短半轴，第三个默认为0，第四个表示弧度大于180度则为1，小于则为0，这在绘制连接到相同节点的连接线时用到；第五个参数，0表示正角，1表示负角，即用来控制弧形凹凸的方向。本文正是结合编号的正负情况来控制该条连接线的凹凸方向，从而达到连接线对称的效果
          var curve = 1.5;
          var homogeneous = 1.2;
          var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr =
              (Math.sqrt(dx * dx + dy * dy) * (d.linknum + homogeneous)) /
              (curve * homogeneous);
          //当节点编号为负数时，对弧形进行反向凹凸，达到对称效果
          if (d.linknum < 0) {
            dr =
              (Math.sqrt(dx * dx + dy * dy) * (-1 * d.linknum + homogeneous)) /
              (curve * homogeneous);
            return (
              "M" +
              d.source.x +
              "," +
              d.source.y +
              "A" +
              dr +
              "," +
              dr +
              " 0 0,0 " +
              d.target.x +
              "," +
              d.target.y
            );
          }
          return (
            "M" +
            d.source.x +
            "," +
            d.source.y +
            "A" +
            dr +
            "," +
            dr +
            " 0 0,1 " +
            d.target.x +
            "," +
            d.target.y
          );
        });

        circle.attr("transform", transform1); //圆圈
        text.attr("transform", transform2); //顶点文字
        edges_text.attr("transform", function (d, i) {
          if (d.target.x < d.source.x) {
            bbox = this.getBBox();
            rx = bbox.x + bbox.width / 2;
            ry = bbox.y + bbox.height / 2;
            return "rotate(180 " + rx + " " + ry + ")";
          } else {
            return "rotate(0)";
          }
        });
      }

      //设置连接线的坐标,使用椭圆弧路径段双向编码
      function linkArc(d) {
        var path =
          "M " +
          d.source.x +
          " " +
          d.source.y +
          " L " +
          d.target.x +
          " " +
          d.target.y;
        return path;
      }
      //设置圆圈和文字的坐标
      function transform1(d) {
        return "translate(" + d.x + "," + d.y + ")";
      }
      function transform2(d) {
        return "translate(" + d.x + "," + d.y + ")";
      }
      function initTips(data) {
        Object.keys(tips).forEach((key) => {
          if (key === data.name) {
          }
          tips[key].attr("display", "none");
        });
      }
      function setTips(data, text) {
        const { clientX: x, clientY: y } = d3.event;
        let target;
        if (tips[data.name]) {
          target = tips[data.name];
          target.attr("display", "block");
        } else {
          target = svg.append("g");
          target
            .append("rect")
            .attr("width", 100)
            .attr("height", 100)
            .attr("fill", "red")
            .attr("rx", 10)
            .attr("ry", 10);
          target
            .append("text")
            .text(text || data.name)
            .attr("fill", "white")
            .attr("x", 20)
            .attr("y", 20)
            .attr("text-anchor", "start")
            .style("font-size", "20px")
            .style("color", "blue")
            .attr("dy", 8);
          tips[data.name] = target;
        }
        target.select("text").attr("x", x + 20);
        target.select("text").attr("y", y + 20);
        target.select("rect").attr("x", x);
        target.select("rect").attr("y", y);
      }
      function setLinkNumber(group, type) {
        if (group.length == 0) return;
        //对该分组内的关系按照方向进行分类，此处根据连接的实体ASCII值大小分成两部分
        var linksA = [],
          linksB = [];
        for (var i = 0; i < group.length; i++) {
          var link = group[i];
          if (link.source < link.target) {
            linksA.push(link);
          } else {
            linksB.push(link);
          }
        }
        //确定关系最大编号。为了使得连接两个实体的关系曲线呈现对称，根据关系数量奇偶性进行平分。
        //特殊情况：当关系都是连接到同一个实体时，不平分
        var maxLinkNumber = 0;
        if (type == "self") {
          maxLinkNumber = group.length;
        } else {
          maxLinkNumber =
            group.length % 2 == 0 ? group.length / 2 : (group.length + 1) / 2;
        }
        //如果两个方向的关系数量一样多，直接分别设置编号即可
        if (linksA.length == linksB.length) {
          var startLinkNumber = 1;
          for (var i = 0; i < linksA.length; i++) {
            linksA[i].linknum = startLinkNumber++;
          }
          startLinkNumber = 1;
          for (var i = 0; i < linksB.length; i++) {
            linksB[i].linknum = startLinkNumber++;
          }
        } else {
          //当两个方向的关系数量不对等时，先对数量少的那组关系从最大编号值进行逆序编号，然后在对另一组数量多的关系从编号1一直编号到最大编号，再对剩余关系进行负编号
          //如果抛开负号，可以发现，最终所有关系的编号序列一定是对称的（对称是为了保证后续绘图时曲线的弯曲程度也是对称的）
          var biggerLinks, smallerLinks;
          if (linksA.length > linksB.length) {
            biggerLinks = linksA;
            smallerLinks = linksB;
          } else {
            biggerLinks = linksB;
            smallerLinks = linksA;
          }

          var startLinkNumber = maxLinkNumber;
          for (var i = 0; i < smallerLinks.length; i++) {
            smallerLinks[i].linknum = startLinkNumber--;
          }
          var tmpNumber = startLinkNumber;

          startLinkNumber = 1;
          var p = 0;
          while (startLinkNumber <= maxLinkNumber) {
            biggerLinks[p++].linknum = startLinkNumber++;
          }
          //开始负编号
          startLinkNumber = 0 - tmpNumber;
          for (var i = p; i < biggerLinks.length; i++) {
            biggerLinks[i].linknum = startLinkNumber++;
          }
        }
      }
      function brushstarted() {
        if (d3.event.sourceEvent.type !== "end") {
          node.classed("selected", function (d) {
            return (d.selected = d.previouslySelected = shiftKey && d.selected);
          });
        }
      }
      function brushed() {
        if (d3.event.sourceEvent.type !== "end") {
          var selection = d3.event.selection;
          node.classed("selected", function (d) {
            return (d.selected =
              d.previouslySelected ^
              (selection != null &&
                selection[0][0] <= d.x &&
                d.x < selection[1][0] &&
                selection[0][1] <= d.y &&
                d.y < selection[1][1]));
          });
        }
      }

      function brushended() {
        if (d3.event.selection != null) {
          d3.select(this).call(d3.event.target.move, null);
        }
      }

function keydowned() {
  if (!d3.event.metaKey) {
    switch (d3.event.keyCode) {
      case 38: nudge( 0, -1); break; // UP
      case 40: nudge( 0, +1); break; // DOWN
      case 37: nudge(-1,  0); break; // LEFT
      case 39: nudge(+1,  0); break; // RIGHT
    }
  }
  shiftKey = d3.event.shiftKey || d3.event.metaKey;
}

function keyupped() {
  shiftKey = d3.event.shiftKey || d3.event.metaKey;
}
    </script>
  </body>
</html>
